# 日付の2進数変換
# 年月日をYYYYMMDDの8桁の整数で表した時
# これを2進数に変換してから逆に並べ，さらに10進数に戻した時，元の日付と同じものに鳴るものを探す
# 期間は前回の東京オリンピック(1964年10月10日)から，次回の東京オリンピック(2020年7月24日)

# 19641010 => 1001 010111011001010110010
# 20200724 => 1001 101000011110100010100
# 必ず左が1001になるなら，反転させたものの右側は1001
# 1001xxxxxxxxxxxxxxxxx1001 になるはず (xは17つ)
# 残りの17桁について考えればいい
# 残りの17桁ということは，左右の8文字ずつを比較して
# 中央の1桁の0 or 1で日付に鳴るものを抽出すればいい

require "date"
require 'benchmark'

result = Benchmark.realtime do
  # 対象の期間で，2進数の5文字目から8文字を抽出して10進数のintに変換
  from_left = 19641010.to_s(2)[4, 8].to_i(2)
  to_left =  20200724.to_s(2)[4, 8].to_i(2)

  # 左右の8文字をループ
  from_left.upto(to_left) do |i|
    l = "%08b" % i  # 左側の8桁  10進数のintを2進数文字列に変換
    r = l.reverse   # 左側の8桁を反転させたものは右側8桁になるはず
    (0..1).each do |m|
      value = "1001#{l}#{m}#{r}1001"
      begin
        # 2進数の文字列を10進数の数値に変換
        puts Date.parse(value.to_i(2).to_s).strftime('%Y%m%d')
        rescue # 有効な日付以外は無視
      end
    end
  end
end

puts "速い方の答えの実行時間 : #{result}s"
# 大体14倍くらい違う

